/*** Autogenerated by WIDL 8.0-rc1 from ../wine-source/dlls/ntoskrnl.exe/plugplay.idl - Do not edit ***/
#include <string.h>

#include "plugplay.h"

#ifndef DECLSPEC_HIDDEN
#define DECLSPEC_HIDDEN
#endif

#ifndef USE_COMPILER_EXCEPTIONS

#include "wine/exception.h"
#undef RpcTryExcept
#undef RpcExcept
#undef RpcEndExcept
#undef RpcTryFinally
#undef RpcFinally
#undef RpcEndFinally
#undef RpcExceptionCode
#undef RpcAbnormalTermination

struct __exception_frame;
typedef int (*__filter_func)(struct __exception_frame *);
typedef void (*__finally_func)(struct __exception_frame *);

#define __DECL_EXCEPTION_FRAME \
    EXCEPTION_REGISTRATION_RECORD frame; \
    __filter_func                 filter; \
    __finally_func                finally; \
    __wine_jmp_buf                jmp; \
    DWORD                         code; \
    unsigned char                 abnormal_termination; \
    unsigned char                 filter_level; \
    unsigned char                 finally_level;

struct __exception_frame
{
    __DECL_EXCEPTION_FRAME
};

static inline void __widl_unwind_target(void)
{
    struct __exception_frame *exc_frame = (struct __exception_frame *)__wine_get_frame();
    if (exc_frame->finally_level > exc_frame->filter_level)
    {
        exc_frame->abnormal_termination = 1;
        exc_frame->finally( exc_frame );
        __wine_pop_frame( &exc_frame->frame );
    }
    exc_frame->filter_level = 0;
    __wine_longjmp( &exc_frame->jmp, 1 );
}

static DWORD __cdecl __widl_exception_handler( EXCEPTION_RECORD *record,
                                               EXCEPTION_REGISTRATION_RECORD *frame,
                                               CONTEXT *context,
                                               EXCEPTION_REGISTRATION_RECORD **pdispatcher )
{
    struct __exception_frame *exc_frame = (struct __exception_frame *)frame;

    if (record->ExceptionFlags & (EH_UNWINDING | EH_EXIT_UNWIND | EH_NESTED_CALL))
    {
        if (exc_frame->finally_level && (record->ExceptionFlags & (EH_UNWINDING | EH_EXIT_UNWIND)))
        {
            exc_frame->abnormal_termination = 1;
            exc_frame->finally( exc_frame );
        }
        return ExceptionContinueSearch;
    }
    exc_frame->code = record->ExceptionCode;
    if (exc_frame->filter_level && exc_frame->filter( exc_frame ) == EXCEPTION_EXECUTE_HANDLER)
        __wine_rtl_unwind( frame, record, __widl_unwind_target );
    return ExceptionContinueSearch;
}

#define RpcTryExcept \
    if (!__wine_setjmpex( &__frame->jmp, &__frame->frame )) \
    { \
        if (!__frame->finally_level) \
            __wine_push_frame( &__frame->frame ); \
        __frame->filter_level = __frame->finally_level + 1;

#define RpcExcept(expr) \
        if (!__frame->finally_level) \
            __wine_pop_frame( &__frame->frame ); \
        __frame->filter_level = 0; \
    } \
    else \

#define RpcEndExcept

#define RpcExceptionCode() (__frame->code)

#define RpcTryFinally \
    if (!__frame->filter_level) \
        __wine_push_frame( &__frame->frame ); \
    __frame->finally_level = __frame->filter_level + 1;

#define RpcFinally \
    if (!__frame->filter_level) \
        __wine_pop_frame( &__frame->frame ); \
    __frame->finally_level = 0;

#define RpcEndFinally

#define RpcAbnormalTermination() (__frame->abnormal_termination)

#define RpcExceptionInit(filter_func,finally_func) \
    do { \
        __frame->frame.Handler = __widl_exception_handler; \
        __frame->filter = (__filter_func)(filter_func); \
        __frame->finally = (__finally_func)(finally_func); \
        __frame->abnormal_termination = 0; \
        __frame->filter_level = 0; \
        __frame->finally_level = 0; \
    } while (0)

#else /* USE_COMPILER_EXCEPTIONS */

#define RpcExceptionInit(filter_func,finally_func) \
    do { (void)(filter_func); } while(0)

#define __DECL_EXCEPTION_FRAME \
    DWORD code;

#endif /* USE_COMPILER_EXCEPTIONS */

#define TYPE_FORMAT_STRING_SIZE 51
#define PROC_FORMAT_STRING_SIZE 35

typedef struct _MIDL_TYPE_FORMAT_STRING
{
    short Pad;
    unsigned char Format[TYPE_FORMAT_STRING_SIZE];
} MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
{
    short Pad;
    unsigned char Format[PROC_FORMAT_STRING_SIZE];
} MIDL_PROC_FORMAT_STRING;


static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/*****************************************************************************
 * plugplay interface
 */

handle_t plugplay_binding_handle;

static const unsigned char * const plugplay__RpcProtseqEndpoint[][2] =
{
    { (const unsigned char *)"ncacn_np", (const unsigned char *)"\\pipe\\wine_plugplay" },
};

static const RPC_CLIENT_INTERFACE plugplay___RpcClientInterface =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x57c680ac,0x7bce,0x4f39,{0x97,0xfd,0xff,0xea,0x56,0x67,0x54,0xd5}},{0,0}},
    {{0x8a885d04,0x1ceb,0x11c9,{0x9f,0xe8,0x08,0x00,0x2b,0x10,0x48,0x60}},{2,0}},
    0,
    1,
    (PRPC_PROTSEQ_ENDPOINT)plugplay__RpcProtseqEndpoint,
    0,
    0,
    0,
};
RPC_IF_HANDLE plugplay_v0_0_c_ifspec DECLSPEC_HIDDEN = (RPC_IF_HANDLE)& plugplay___RpcClientInterface;

static const MIDL_STUB_DESC plugplay_StubDesc;

struct __frame_plugplay_register_listener
{
    __DECL_EXCEPTION_FRAME
    MIDL_STUB_MESSAGE _StubMsg;
    RPC_BINDING_HANDLE _Handle;
};

static void __finally_plugplay_register_listener( struct __frame_plugplay_register_listener *__frame )
{
    NdrFreeBuffer(&__frame->_StubMsg);
}

plugplay_rpc_handle __cdecl plugplay_register_listener(
    void)
{
    struct __frame_plugplay_register_listener __f, * const __frame = &__f;
    plugplay_rpc_handle _RetVal;
    RPC_MESSAGE _RpcMessage;
    __frame->_Handle = 0;

    RpcExceptionInit( 0, __finally_plugplay_register_listener );
    RpcTryFinally
    {
        NdrClientInitializeNew(&_RpcMessage, &__frame->_StubMsg, &plugplay_StubDesc, 0);
        __frame->_Handle = plugplay_binding_handle;

        __frame->_StubMsg.BufferLength = 0;
        NdrGetBuffer(&__frame->_StubMsg, __frame->_StubMsg.BufferLength, __frame->_Handle);

        NdrSendReceive(&__frame->_StubMsg, __frame->_StubMsg.Buffer);

        __frame->_StubMsg.BufferStart = _RpcMessage.Buffer;
        __frame->_StubMsg.BufferEnd = __frame->_StubMsg.BufferStart + _RpcMessage.BufferLength;

        if ((_RpcMessage.DataRepresentation & 0x0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION)
            NdrConvert(&__frame->_StubMsg, (PFORMAT_STRING)&__MIDL_ProcFormatString.Format[0]);

        _RetVal = 0;
        NdrClientContextUnmarshall(
            &__frame->_StubMsg,
            (NDR_CCONTEXT *)&_RetVal,
            __frame->_Handle);

    }
    RpcFinally
    {
        __finally_plugplay_register_listener( __frame );
    }
    RpcEndFinally

    return _RetVal;
}

struct __frame_plugplay_get_event
{
    __DECL_EXCEPTION_FRAME
    MIDL_STUB_MESSAGE _StubMsg;
    RPC_BINDING_HANDLE _Handle;
};

static void __finally_plugplay_get_event( struct __frame_plugplay_get_event *__frame )
{
    NdrFreeBuffer(&__frame->_StubMsg);
}

DWORD __cdecl plugplay_get_event(
    plugplay_rpc_handle handle,
    BYTE **data,
    unsigned int *size)
{
    struct __frame_plugplay_get_event __f, * const __frame = &__f;
    DWORD _RetVal;
    RPC_MESSAGE _RpcMessage;
    __frame->_Handle = 0;

    RpcExceptionInit( 0, __finally_plugplay_get_event );
    if (!data) RpcRaiseException(RPC_X_NULL_REF_POINTER);
    if (!size) RpcRaiseException(RPC_X_NULL_REF_POINTER);
    RpcTryFinally
    {
        NdrClientInitializeNew(&_RpcMessage, &__frame->_StubMsg, &plugplay_StubDesc, 1);
        if (handle != 0)
            __frame->_Handle = NDRCContextBinding(handle);
        else
            RpcRaiseException(RPC_X_SS_IN_NULL_CONTEXT);

        __frame->_StubMsg.BufferLength = 24;
        NdrGetBuffer(&__frame->_StubMsg, __frame->_StubMsg.BufferLength, __frame->_Handle);

        NdrClientContextMarshall(
            &__frame->_StubMsg,
            (NDR_CCONTEXT)handle,
            0);

        NdrSendReceive(&__frame->_StubMsg, __frame->_StubMsg.Buffer);

        __frame->_StubMsg.BufferStart = _RpcMessage.Buffer;
        __frame->_StubMsg.BufferEnd = __frame->_StubMsg.BufferStart + _RpcMessage.BufferLength;

        if ((_RpcMessage.DataRepresentation & 0x0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION)
            NdrConvert(&__frame->_StubMsg, (PFORMAT_STRING)&__MIDL_ProcFormatString.Format[4]);

        NdrPointerUnmarshall(
            &__frame->_StubMsg,
            (unsigned char **)&data,
            (PFORMAT_STRING)&__MIDL_TypeFormatString.Format[24],
            0);

        __frame->_StubMsg.Buffer = (unsigned char *)(((ULONG_PTR)__frame->_StubMsg.Buffer + 3) & ~0x3);
        if (__frame->_StubMsg.Buffer + sizeof(unsigned int) > __frame->_StubMsg.BufferEnd)
        {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
        }
        *size = *(unsigned int *)__frame->_StubMsg.Buffer;
        __frame->_StubMsg.Buffer += sizeof(unsigned int);

        __frame->_StubMsg.Buffer = (unsigned char *)(((ULONG_PTR)__frame->_StubMsg.Buffer + 3) & ~0x3);
        if (__frame->_StubMsg.Buffer + sizeof(DWORD) > __frame->_StubMsg.BufferEnd)
        {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
        }
        _RetVal = *(DWORD *)__frame->_StubMsg.Buffer;
        __frame->_StubMsg.Buffer += sizeof(DWORD);

    }
    RpcFinally
    {
        __finally_plugplay_get_event( __frame );
    }
    RpcEndFinally

    return _RetVal;
}

struct __frame_plugplay_unregister_listener
{
    __DECL_EXCEPTION_FRAME
    MIDL_STUB_MESSAGE _StubMsg;
    RPC_BINDING_HANDLE _Handle;
};

static void __finally_plugplay_unregister_listener( struct __frame_plugplay_unregister_listener *__frame )
{
    NdrFreeBuffer(&__frame->_StubMsg);
}

void __cdecl plugplay_unregister_listener(
    plugplay_rpc_handle handle)
{
    struct __frame_plugplay_unregister_listener __f, * const __frame = &__f;
    RPC_MESSAGE _RpcMessage;
    __frame->_Handle = 0;

    RpcExceptionInit( 0, __finally_plugplay_unregister_listener );
    RpcTryFinally
    {
        NdrClientInitializeNew(&_RpcMessage, &__frame->_StubMsg, &plugplay_StubDesc, 2);
        if (handle != 0)
            __frame->_Handle = NDRCContextBinding(handle);
        else
            RpcRaiseException(RPC_X_SS_IN_NULL_CONTEXT);

        __frame->_StubMsg.BufferLength = 24;
        NdrGetBuffer(&__frame->_StubMsg, __frame->_StubMsg.BufferLength, __frame->_Handle);

        NdrClientContextMarshall(
            &__frame->_StubMsg,
            (NDR_CCONTEXT)handle,
            0);

        NdrSendReceive(&__frame->_StubMsg, __frame->_StubMsg.Buffer);

        __frame->_StubMsg.BufferStart = _RpcMessage.Buffer;
        __frame->_StubMsg.BufferEnd = __frame->_StubMsg.BufferStart + _RpcMessage.BufferLength;

    }
    RpcFinally
    {
        __finally_plugplay_unregister_listener( __frame );
    }
    RpcEndFinally
}

struct __frame_plugplay_send_event
{
    __DECL_EXCEPTION_FRAME
    MIDL_STUB_MESSAGE _StubMsg;
    RPC_BINDING_HANDLE _Handle;
};

static void __finally_plugplay_send_event( struct __frame_plugplay_send_event *__frame )
{
    NdrFreeBuffer(&__frame->_StubMsg);
}

void __cdecl plugplay_send_event(
    DWORD event_code,
    const BYTE *data,
    unsigned int size)
{
    struct __frame_plugplay_send_event __f, * const __frame = &__f;
    RPC_MESSAGE _RpcMessage;
    __frame->_Handle = 0;

    RpcExceptionInit( 0, __finally_plugplay_send_event );
    if (!data) RpcRaiseException(RPC_X_NULL_REF_POINTER);
    RpcTryFinally
    {
        NdrClientInitializeNew(&_RpcMessage, &__frame->_StubMsg, &plugplay_StubDesc, 3);
        __frame->_Handle = plugplay_binding_handle;

        __frame->_StubMsg.BufferLength = 16;
        __frame->_StubMsg.MaxCount = (ULONG_PTR)size;

        NdrConformantArrayBufferSize(
            &__frame->_StubMsg,
            (unsigned char *)data,
            (PFORMAT_STRING)&__MIDL_TypeFormatString.Format[36]);

        NdrGetBuffer(&__frame->_StubMsg, __frame->_StubMsg.BufferLength, __frame->_Handle);

        MIDL_memset(__frame->_StubMsg.Buffer, 0, (0x4 - (ULONG_PTR)__frame->_StubMsg.Buffer) & 0x3);
        __frame->_StubMsg.Buffer = (unsigned char *)(((ULONG_PTR)__frame->_StubMsg.Buffer + 3) & ~0x3);
        *(DWORD *)__frame->_StubMsg.Buffer = event_code;
        __frame->_StubMsg.Buffer += sizeof(DWORD);

        __frame->_StubMsg.MaxCount = (ULONG_PTR)size;

        NdrConformantArrayMarshall(
            &__frame->_StubMsg,
            (unsigned char *)data,
            (PFORMAT_STRING)&__MIDL_TypeFormatString.Format[36]);

        MIDL_memset(__frame->_StubMsg.Buffer, 0, (0x4 - (ULONG_PTR)__frame->_StubMsg.Buffer) & 0x3);
        __frame->_StubMsg.Buffer = (unsigned char *)(((ULONG_PTR)__frame->_StubMsg.Buffer + 3) & ~0x3);
        *(unsigned int *)__frame->_StubMsg.Buffer = size;
        __frame->_StubMsg.Buffer += sizeof(unsigned int);

        NdrSendReceive(&__frame->_StubMsg, __frame->_StubMsg.Buffer);

        __frame->_StubMsg.BufferStart = _RpcMessage.Buffer;
        __frame->_StubMsg.BufferEnd = __frame->_StubMsg.BufferStart + _RpcMessage.BufferLength;

    }
    RpcFinally
    {
        __finally_plugplay_send_event( __frame );
    }
    RpcEndFinally
}

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_STUB_DESC plugplay_StubDesc =
{
    (void *)& plugplay___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    {
        &plugplay_binding_handle,
    },
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x10001, /* Ndr library version */
    0,
    0x50200ca, /* MIDL Version 5.2.202 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
};


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
{
    0,
    {
/* 0 (return value) */
        0x52,    /* FC_RETURN_PARAM */
        0x01,
        NdrFcShort(0x2),	/* type offset = 2 */
/* 4 (parameter handle) */
        0x4d,    /* FC_IN_PARAM */
        0x01,
        NdrFcShort(0x6),	/* type offset = 6 */
/* 8 (parameter data) */
        0x51,    /* FC_OUT_PARAM */
        0x01,
        NdrFcShort(0x18),	/* type offset = 24 */
/* 12 (parameter size) */
        0x51,    /* FC_OUT_PARAM */
        0x01,
        NdrFcShort(0x1c),	/* type offset = 28 */
/* 16 (return value) */
        0x53,    /* FC_RETURN_PARAM_BASETYPE */
        0x08,    /* FC_LONG */
/* 18 (parameter handle) */
        0x4d,    /* FC_IN_PARAM */
        0x01,
        NdrFcShort(0x20),	/* type offset = 32 */
/* 22 (void) */
        0x5b,	/* FC_END */
        0x5c,	/* FC_PAD */
/* 24 (parameter event_code) */
        0x4e,    /* FC_IN_PARAM_BASETYPE */
        0x08,    /* FC_LONG */
/* 26 (parameter data) */
        0x4d,    /* FC_IN_PARAM */
        0x01,
        NdrFcShort(0x24),	/* type offset = 36 */
/* 30 (parameter size) */
        0x4e,    /* FC_IN_PARAM_BASETYPE */
        0x08,    /* FC_LONG */
/* 32 (void) */
        0x5b,	/* FC_END */
        0x5c,	/* FC_PAD */
        0x0
    }
};

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
{
    0,
    {
        NdrFcShort(0x0),
/* 2 (plugplay_rpc_handle) */
        0x30,	/* FC_BIND_CONTEXT */
        0x30,	/* Context flags: return, out, */
        0x0,	/* rundown routine */
        0, /* FIXME: param num */
/* 6 (plugplay_rpc_handle) */
        0x30,	/* FC_BIND_CONTEXT */
        0x41,	/* Context flags: can't be null, in, */
        0x0,	/* rundown routine */
        0, /* FIXME: param num */
/* 10 (BYTE *) */
        0x1b,	/* FC_CARRAY */
        0x0,	/* 0 */
        NdrFcShort(0x1),	/* 1 */
        0x29,	/* Corr desc: parameter size, FC_ULONG */
        0x54,	/* FC_DEREFERENCE */
        NdrFcShort(0x8),	/* offset = 8 */
        0x01,	/* FC_BYTE */
        0x5b,	/* FC_END */
/* 20 */
        0x12, 0x0,	/* FC_UP */
        NdrFcShort(0xfff4),	/* Offset= -12 (10) */
/* 24 (BYTE **) */
        0x11, 0x14,		/* FC_RP [allocated_on_stack] [pointer_deref] */
        NdrFcShort(0xfffa),	/* Offset= -6 (20) */
/* 28 (unsigned int *) */
        0x11, 0xc,	/* FC_RP [allocated_on_stack] [simple_pointer] */
        0x09,	/* FC_ULONG */
        0x5c,	/* FC_PAD */
/* 32 (plugplay_rpc_handle) */
        0x30,	/* FC_BIND_CONTEXT */
        0x41,	/* Context flags: can't be null, in, */
        0x0,	/* rundown routine */
        0, /* FIXME: param num */
/* 36 (const BYTE *) */
        0x1b,	/* FC_CARRAY */
        0x0,	/* 0 */
        NdrFcShort(0x1),	/* 1 */
        0x29,	/* Corr desc: parameter size, FC_ULONG */
        0x0,	/* no operators */
        NdrFcShort(0x8),	/* offset = 8 */
        0x01,	/* FC_BYTE */
        0x5b,	/* FC_END */
/* 46 */
        0x11, 0x0,	/* FC_RP */
        NdrFcShort(0xfff4),	/* Offset= -12 (36) */
        0x0
    }
};

